[{"body":"Objetivos Objetivos de este tema\nQué veremos aquí una parte de un todo\nAnalizaremos lo que este módulo implica a nivel de objetivos.\nObjetivos de este módulo y cómo se relaciona con el resto. Tecnologías en la web Qué tecnologías se usan en el desarrollo web.\nQué tecnologías vamos a usar nosotras. Arquitectura web Qué es una arquitectura web\nPrincipales componentes o elementos en una arquitectura web\nPuesta en marcha del sistema Instalaciones en el propio equipo Instalar los componentes que necesitamos\nServicios en nuestro servidor\nAplicaciones que vamos a utilizar para desarrollar\nAl finalizar el tema Al final de este tema… Conocer nombres de tecnologías. Conocer su existencia y para qué se usan. \u003cp\u003eNo pretendemos conocer su uso, ni dominarlas, nos especializaremos en alguna de ellas.\u003c/p\u003e Diferenciar y relacionar arquitectura, tecnología y herramientas para el desarrollo.\nTecnología y herramientas a veces podrían ser sinónimos\nNo se trata de ser muy purista, sino crítica y curiosa.\nTener el sistema preparado para empezar a trabajar ","categories":"","description":"","excerpt":"Objetivos Objetivos de este tema\nQué veremos aquí una parte de un todo …","ref":"/docs/01_web/","tags":"","title":"Web"},{"body":"Creando el proyecto Vamos a instalar e un\nmkdir books cd books 1 2 3 4 5 laravel new api --git cd api git init git add * git commit -m inicial Vamos documentando el Readme.md\nRutas Como la aplicación va a ser un API, vamos al fichero de rutas routes/api.php Entre web.php y api.php hay como diferencias los middeleware que se utilizan. Esto se puede ver en\nEn el caso de api.php, casi el único middleware que utiliza es el ThrottleRequests, es decir, poder crear un límite de peticiones, no necesitamos sesiones, cookies ni compartir errores entre ficheros. Vemos si hacemos un route:list que las rutas que aparecen son las de web.php y también las de api.php que no habíamos visto Las de api tiene prefijo, es por que se establece en el routeservicesproviders.php\nAhora vamos a crar un modelo, y queremos crear también la migración y el factory y también un controlador con todos los métodos de gestión rest que ya hemos visto 1 php artisan make:model Book -mf --api Ahora debemos de agregar rutas imagen api De todas ellas, como solo estamos creando un api, que es para consultar, no realizaremos la acción de editar para modificar, ni de crear por lo que las rutas nos quedarían imagen api Creamos estas rutas en el fichero routes/api.php 1 Route::apiResource('books', \\App\\Http\\Controllers\\BookController::class); Podemos ejectura route:list para ver las 5 rutas que hemos creado\n","categories":"","description":"","excerpt":"Creando el proyecto Vamos a instalar e un\nmkdir books cd books 1 2 3 4 …","ref":"/docs/laravel/api/1.instalacion/","tags":"","title":"01_Introducción y rutas"},{"body":"Laravel: un framework de php TODO\nQué es un framework Instalar composer Instalar laravel installer Crear un proyecto de laravel Estructuras de carpetas !(listado_frameworks.png)[listado_frameworks.png]\n","categories":"","description":"","excerpt":"Laravel: un framework de php TODO\nQué es un framework Instalar …","ref":"/docs/laravel/01_introducci%C3%B3n/","tags":"","title":"Instalación"},{"body":"Levantar el proyecto Rutas Artisan MVC ","categories":"","description":"","excerpt":"Levantar el proyecto Rutas Artisan MVC ","ref":"/docs/laravel/02_instalaci%C3%B3n/","tags":"","title":"Introducción a su funcinamiento"},{"body":"Plantillas con Blade Blade Una herramienta poderosa y flexible incluida en Laravel, que nos va a permitir escribir html e incluir php y visualizar datos del servidor Los ficheros blade, tienen extensión blade.php y estarán ubicados en la carpeta ./resources/view .\nCuando hagamos referencia a los ficheros blade, esta información no hay que especificar, ni su ubicación, ni su extensión, como podemos ver en el siguiente ejemplo\nContenido de un fichero blade Dentro de un fichero blade (.blade.php) En él podemos encontrar el siguiente tipo de código o instrucciones:\n(como cualquier página html)\nPara mostrar el contenido de variables PHP. Blade automáticamente escapa el HTML en las variables para evitar ataques XSS. También para comentar, en lugar de \u003c!- - Comentario html - -\u003e, podemos usar {{- - Comentario html - -}}\npara utilizar directivas/estructuras de control propias de laravel, como como condicionales y bucles. Por ejemplo, @if, @foreach, @switch, entre otras. También acciones propias de laravel con sus directivas, como heredar de una plantilla o incluir en una determinada sección un código html como veremos a continuación en las herecias\nHerencia: Creando un layout Concepto En el desarrollo web con Laravel, la herencia en las plantillas Blade proporciona una forma eficiente de garantizar una estructura consistente en todas las páginas , fomentando un diseño corporativo uniforme.\nIdea de su uso/funcionamiento Con este concepto se establece una página inicial o ’layout’ que define los aspectos generales de la interfaz, dejando espacios designados para personalizaciones específicas Con ello, cada página individual hereda de esta plantilla principal , permitiendo inlcuir su propio contenido (el de la página) sin perder la coherencia visual (el de la plantilla).\nEste método facilita la gestión y mantenimiento del diseño, ya que cualquier cambio realizado en la plantilla principal se reflejará automáticamente en todas las páginas que heredan de ella. De este modo, la herencia en las plantillas Blade contribuye a una experiencia de desarrollo eficiente y a la creación de interfaces consistentes y atractivas.\nComentarios blade Insertando comentarios en fichero .blade.php Dentro de un fichero Blade , podemos comentar de dos maneras\nComentarios HTML (\u003c!-- Comentarios --\u003e) Comentarios Blade ({{-- Comentarios --}}) Hay diferencias significativas entre comentar con \u003c!-- Comentarios --\u003e y {{-- Comentarios --}} en un fichero Blade de Laravel. Estas diferencias se relacionan principalmente con cómo se manejan y se muestran estos comentarios en el HTML generado y enviado al navegador.\nComentarios HTML (\u003c!-- Comentarios --\u003e):\nSon comentarios estándar de HTML. Serán visibles en el código fuente del HTML generado y enviado al navegador. Cualquiera que inspeccione el código fuente de la página en el navegador podrá ver estos comentarios. Son útiles para anotaciones que no afectan la presentación de la página pero podrían ser de ayuda durante el desarrollo o para otros desarrolladores. Comentarios Blade ({{-- Comentarios --}}):\nSon específicos del motor de plantillas Blade de Laravel. No serán incluidos en el HTML final generado. Esto significa que no aparecerán en el código fuente de la página cuando se vea en un navegador. Son útiles para dejar notas o comentarios en el código que solo deben ser visibles durante el desarrollo y no deben ser expuestos a los usuarios finales o en el ambiente de producción. Proporcionan una manera de hacer anotaciones en las plantillas Blade sin afectar lo que ve el usuario. Creando un diseño Creando un diseño Primero creamos un mockup de nuestro diseño\nPara ello usaremos Balsamiq (varias herramientas como Pencil están disponibles) Se propone un disaño tradicional de 4 secciones en horizontal según se pude ver en la imagens siguiente:\nPara la implementación tendremos que tener instalado tailwindcss en El header El nav o menú de navegación El main El footer Estableciendo componentes Rutas Artisan MVC ","categories":"","description":"","excerpt":"Plantillas con Blade Blade Una herramienta poderosa y flexible …","ref":"/docs/laravel/04_plantillas/01_blade/","tags":"","title":"Plantillas en Laravel"},{"body":"Plantillas Laravel usa el gestor de plantillas Blade\nRutas Artisan MVC ","categories":"","description":"","excerpt":"Plantillas Laravel usa el gestor de plantillas Blade\nRutas Artisan MVC …","ref":"/docs/laravel/04_plantillas/","tags":"","title":"Plantillas en Laravel"},{"body":"Plantillas Laravel usa el gestor de plantillas Blade\nRutas Artisan MVC ","categories":"","description":"","excerpt":"Plantillas Laravel usa el gestor de plantillas Blade\nRutas Artisan MVC …","ref":"/docs/laravel/05_multilenguaje/","tags":"","title":"Plantillas en Laravel"},{"body":"Directorio Routes Rutas Artisan MVC ","categories":"","description":"","excerpt":"Directorio Routes Rutas Artisan MVC ","ref":"/docs/laravel/03_rutas/","tags":"","title":"Rutas en Laravel"},{"body":" Aspectos vistos en la tutoría Conceptos importantes en el desarrollo web\nEn esta sección mostramos un resumen de puntos concretos vistos en las tutorías Según vayamos teniendo tutorías actualizamos estos puntos.\nDesarrollo web: Instalación: PHP: PHP sintaxis básica: ","categories":"","description":"","excerpt":" Aspectos vistos en la tutoría Conceptos importantes en el desarrollo …","ref":"/docs/","tags":"","title":"Documentación"},{"body":"Intentando ver el icono de php icon = “fas fa-laptop-code”\n","categories":"","description":"","excerpt":"Intentando ver el icono de php icon = “fas fa-laptop-code”\n","ref":"/docs/02_php/","tags":"","title":"PHP"},{"body":"Instalación en Laravel Una vez creado el proyecto de laravel, instalamos la última versión de vue (marzo 2023, Vue 3) Para ello hemos de instalarlo tanto para usarlo , como para que vite pueda hacer su transpilación\n1 2 npm install vue@next --save-dev npm install @vitejs/plugin-vue Modificando ficheros Ahora toca invocarlo. Por un lado especificamos a vite que use este framework, por lo que accedemos al fichero de configuración de vite\n1 2 3 4 5 6 7 8 9 10 11 12 import { defineConfig } from 'vite'; import laravel from 'laravel-vite-plugin'; import vue from '@vitejs/plugin-vue'; //línea a añadir export default defineConfig({ plugins: [ vue(), //Línea a añadir laravel({ input: ['resources/css/app.css', 'resources/js/app.js'],refresh: true, }), ], }); Ahora debemos cargar una instancia de vue en un fichero js que carguemos en nuestra página html. Para ello primero cargamos una instacia de vue en ‘‘‘‘‘resources/js/app.js’’’’’\n1 2 3 4 5 import {createApp} from \"vue\"; import {createApp} from \"vue/dist/vue.esm-bundler\"; createApp({ }).mount(\"#app\"); Ahora debemos instalar nuestro elemento con id app que hemos indicado en el método o evento mount en nuestra página html, y en ella incluir este script\nEn nuestra página layout que vamos a usar en todas las páginas de nuestro proyecto escribimos\n1 2 3 4 5 6 7 8 9 10 11 12 \u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003c!-- código html con sintaxis blade--\u003e @vite([\"resources/css/app.css\",\"resources/js/app.js\" ]) \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003c!-- código html con sintaxis blade--\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e `` ","categories":"","description":"","excerpt":"Instalación en Laravel Una vez creado el proyecto de laravel, …","ref":"/docs/vue/1_instalacion/","tags":"","title":"01_Introducción"},{"body":"Ejecutar la migración Debemos de crear la base de datos y poderla cargar\nmétodos de get Para ello escribimos el código de index y show con las respectivas rutas 1 2 http://localhost:8000/api/books =\u003e obtener todos los libros http://localhost:8000/api/books/1 =\u003e obtener el libro de id 1 Como lo que nos retorna es un Json, podemos instalar algún plugin para verlo de forma mas legible en el navegador, por ejemplo jsonview\nmetodos PATCH DELETE y POST Ahora queremos probar estas otras rutas Para ello debemos de tener una herramienta que nos permita realizar llamadas de este tipo, con el navegador no podemos y estamos haciendo un api, no la parte de uso, sino de servicio Podemos instalar postman 1 2 3 sudo apt install snapd sudo apt update sudo snap install postman *Podemos probar una solicitud por post y hacer que el método store me retorne un texto, lo mismo con patch y con delete y ver qué es\npost Vemos que con el post, en la parte del body del mensaje hay que aportar algún valor Para ello vamos al body y usamo el form-data para pasar valores\nPasar parámetros para el post Escribmos el código del método store añadiendo un nuevo libro\nPodemos ver qué ocurre si ponemos otro parámetro o no pasamos ningún libro\nPara poder ver los errores debemos habilitar los hedear para en formato json aceptar los errores Añadir la opción de ver los errores en el navegador Podemos establecer en el servidor el control del error indicando lo que queramos que se muestre si no aparece el error 1 2 3 4 5 6 7 8 9 10 11 12 public function store(Request $request) { $request-\u003evalidate([ 'titulo'=\u003e['required'] ]); $book = new Book(); $book-\u003etitulo=$request-\u003einput('titulo'); $book-\u003esave(); return $book; // } PATH La actualización es muy similar al storage, con la diferencia que solo queremos actualizar, no agregar En el postman, para pasar los nuevos datos usamos modo de pasar datos al método patch 1 2 3 4 5 6 7 8 public function update(Request $request, Book $book){ $request-\u003evalidate([ 'titulo'=\u003e['required'] ]); $book-\u003etitulo=$request-\u003einput('titulo'); $book-\u003eupdate(); return $book; } DELETE En este caso el método delete es muy sencillo. Podemos retornar un mensaje\n1 2 3 4 5 public function destroy(Book $book) { $book-\u003edelete(); return \"Se ha borrado \".$book-\u003etitulo; } ","categories":"","description":"","excerpt":"Ejecutar la migración Debemos de crear la base de datos y poderla …","ref":"/docs/laravel/api/2.visiongeneral/","tags":"","title":"Controlador"},{"body":"Creando un diseño Proceso de diseño Diseñar es un aspecto fundamentan antes de crear las páginas Para crear un proyecto debemos crear previaemnte los mockups o Prototipados de pantallas Posteriormente hemos de crear las páginas usando los estilos adecuados para conseguir los diseños previamente prototipados, esto implicará usar html y css Para crear los diseños se usan herramientas gráficas de prototipado, y para el css normalmente usaremos algún fremework tipo Bootstrap o tailwindcss\nHerramientas para el diseño Vamos a usar Balsamiq porque disponemos de licencia estudiante en el centro Existen varias herramientas alternativas:\nPencil Project: Pencil Project es una herramienta de prototipado de código abierto que te permite crear mockups de manera sencilla. Es fácil de usar y ofrece una variedad de elementos predefinidos. MockFlow: MockFlow es una plataforma en línea que ofrece una herramienta de diseño de wireframes y mockups. La versión gratuita tiene algunas limitaciones, pero aún así proporciona funcionalidades útiles. Balsamiq Cloud (versión gratuita) ): Balsamiq, conocido por su aplicación de escritorio, también ofrece una versión en línea gratuita llamada Balsamiq Cloud que permite crear mockups y wireframes. Figma: Figma es una herramienta de diseño colaborativo en línea que permite crear mockups, wireframes y prototipos. Tiene una versión gratuita con muchas funcionalidades. Wireframe.cc: Wireframe.cc es una herramienta simple y fácil de usar para crear wireframes rápidos y sencillos. Puedes comenzar a usarla directamente en el navegador. Tailwind: framework de css Diseño del layout Diseño header Diseño nav Diseño main Diseño footer ","categories":"","description":"","excerpt":"Creando un diseño Proceso de diseño Diseñar es un aspecto fundamentan …","ref":"/docs/laravel/04_plantillas/02_creandodise%C3%B1o/","tags":"","title":"Diseñando el layout"},{"body":"Conceptos de desarrollo web al lado del servidor ","categories":"","description":"","excerpt":"Conceptos de desarrollo web al lado del servidor ","ref":"/docs/laravel/","tags":"","title":"Hugo: static developer web"},{"body":" Contenido sobre vue\n*La palabra Vue (pronunciado «viú») cuya traducción del francés es «view» (vista). *Vue es un framework frontend, concretamente de javascript *En un model MVC la vista es la parte del html, y este framework se centra en ese aspecto. * *En esta línea tenemos otros conocidos frameworks como React, Angular y Svelte. *El mayor uso que se hace de este framework es usando componentes, que es como lo vamos a utilizar con laravel. Imagen de Vue js ","categories":"","description":"","excerpt":" Contenido sobre vue\n*La palabra Vue (pronunciado «viú») cuya …","ref":"/docs/vue/","tags":"","title":"Vue"},{"body":"Tipos de test en laravel Realizar test, es muy importante. Muchas veces pensamos que como no los necesitamos para que la apliación funcione lo dejamos para el final, o simplemente no lo hacemos (para ejemplo yo mismo :cold_face: )\nLaravel ya aporta una estructura de test, que podemos ver en la carpeta correspondiente. En ella vemos que tenemos dos tipos de test:\nFeature Test de características dónde se testean diferentes componentes interactuando entre ellos\nUnit Que testean métodos concretos del código\n*El funcionamiento de los métodos creados es el muy parecido. Para esta api, vamos a realizar los test usando los FeatureText\nEjecutando los test en laravel En el terminal escribimos 1 php artisan test Vamos a crear métodos para validar cada uno de los 5 métodos que tenemos en el controlador Un test es un método que nos va a permitir validar otro método En el método del test, básicamente vamos a hacer 3 acciones *Invocar al método que queremos testear pasándole los valores que consideremos *Comprobar que lo que devuelve ese método que validamos es lo que esperamos que devuelva *Informar de ello\nLos test no son infalibles, es decir, nosotros validamos lo que consideramos, por ejemplo si valido un método de fecha, si le paso una fecha incorrecta, espero que me lo diga, y si es correcta igual, eso me permitiría validar el método. Veamos cómo se realizan estas acciones **1.- Creamos una clase para el test del api. ** El método de test, se espera que termine con la palabra Test. Creamos una clase llamada BookApiTest para nuestro ejemplo 1 php artisan make:test BookApiTest Empezamos validando el método index para ello vamos a crear un método Importante que el método empiece por la palabra test 1 2 3 public function test_can_get_all_books(): void{ } Pero claro, necesitamos tener la base de datos poblada y comprobar que cuando consultamos obtenemos todos los registros Pero no queremos tocar la base de datos original, si no que vamos a craar una base de datos para los test, para lo cual vamos a usar la clase (traid) RefreshDatabase que nos ofrece Laravel Creamos una nueva base de datos (también podríamos usar sqlite en memoria) Para configurar la base de datos de test, primero la creamos en nuestro gestor creamos la base de datos api_test Ahora lo configuramos en el fichero phpunit.xml 1 2 3 4 5 6 \u003cphp\u003e \u003cenv name=\"APP_ENV\" value=\"testing\"/\u003e \u003cenv name=\"BCRYPT_ROUNDS\" value=\"4\"/\u003e \u003cenv name=\"CACHE_DRIVER\" value=\"array\"/\u003e \u003c!-- \u003cenv name=\"DB_CONNECTION\" value=\"sqlite\"/\u003e --\u003e \u003cenv name=\"DB_DATABASE\" value=\"api_test\"/\u003e Para poblar la base de datos de pruebas, vamos a usar el factory que creamos cuando construimos el modelo\nUna vez creado, lo invocamos desde el método credado Vamos simplemente a crear un libro y visualizarlo 1 2 3 4 5 6 7 8 9 10 11 12 //En el factory public function definition(): array{ return [ 'titulo'=\u003efake()-\u003esentence(), ]; } //En el test public function test_can_get_all_books(): void{ $book = Book::factory()-\u003ecreate(); dd($book); } Por ejemplo vamos a creaer 4 libros y verificamos que haya 4 libros 1 2 3 4 5 6 public function test_can_get_all_books(): void { $book = Book::factory()-\u003ecount(4)-\u003ecreate(); dd($book-\u003ecount()); } Ahora vamos a ver lo que retorno si hacemos una solicitud get 1 2 3 4 5 public function test_can_get_all_books(): void { $book = Book::factory()-\u003ecount(4)-\u003ecreate(); $this-\u003eget(\"/api/books\")-\u003edump(); } Ahora que vemos esto, se trataría de verficar los libros que nos devuelve son los que hemos creado Para ello vamos a hacer uns aserción y verficar que esto funciona. para ello vamos a recoger la respuesta y vamos a comparar por ejemplo los títulos de los dos primeros libros recibidos con los títulos de los dos primeros libros creados. 1 2 3 4 5 6 7 8 9 10 11 12 13 public function test_can_get_all_books(): void { $book = Book::factory()-\u003ecount(4)-\u003ecreate(); $response = $this-\u003egetJson(route(\"books.index\")); $response-\u003eassertJsonFragment([ 'titulo'=\u003e$book[0]-\u003etitulo ]) -\u003eassertJsonFragment([ 'titulo'=\u003e$book[1]-\u003etitulo ]); } Ejecutamos el test y vemos que funciona Probar por ejemplo a modificar el método index y ver que no funciona, por ejemplo si solo retornamos un libre en lugar de todos , o no devolvemos nada … **Verificar el método show 1 2 3 4 5 6 7 8 9 10 11 12 /** * @test */ public function can_get_one_book():void{ $book=Book::factory()-\u003ecreate(); $response = $this-\u003egetJson(route(\"books.index\")); $response-\u003eassertJsonFragment([ 'titulo'=\u003e$book-\u003etitulo ]); } * Observa que si ponemos la directiva **@test** ya no hay que hacer que el nombre del método empiece por la palabra **test** Verificar el método store 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * @test */ public function can_crate_book():void{ $this-\u003epostJson(route('books.store'),[ 'titulo'=\u003e\"Mi libro de pruebas\" ])-\u003eassertJsonFragment([ 'titulo'=\u003e\"Mi libro de pruebas\" ]); $this-\u003eassertDatabaseHas('books', ['titulo'=\u003e\"Mi libro de pruebas\"] ); } En este caso hacemos dos aserciones, podemos ver cómo tanto con solo una, como con dos, funciona correctamente Vamos a ver cómo podemos también validar que si no le pasamos nada, nuestra aplicación esparemos que nos de un error. Por ejemplo si quitáramos la validación en el controlador, 1 2 3 4 public function can_crate_book():void{ $this-\u003epostJson(route('books.store'),[]) -\u003eassertJsonValidationErrors('titulo'); /.... Actualizar un libro 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * @test */ public function can_update_book():void{ $book=Book::factory()-\u003ecreate(); $this-\u003epatch(route(\"books.update\",$book),[ 'titulo'=\u003e\"Libro editado\" ])-\u003eassertJsonFragment([ 'titulo'=\u003e'Libro editado' ]); //Verificamos también en la base de datos $this-\u003eassertDatabaseHas('books',[ 'titulo'=\u003e\"Libro editado\" ]); } *Podemos (debemos) de verificar también la validación 1 2 3 //Validamos también la validación $this-\u003epatch(route(\"books.update\",$book),[]) -\u003eassertJsonValidationErrors('titulo'); Borrar un libro *En este caso vamos a eliminar un libro y verificar que no existe 1 2 3 4 5 6 7 8 9 10 11 12 13 /** * @test */ public function can_delete_book(): void { $book = Book::factory()-\u003ecreate(); //Validamos también la validación $respuesta = $this-\u003edeleteJson(route(\"books.destroy\", $book), []) -\u003eassertContent(\"Se ha borrado \".$book-\u003etitulo); // -\u003eassertNoContent(); } ","categories":"","description":"","excerpt":"Tipos de test en laravel Realizar test, es muy importante. Muchas …","ref":"/docs/laravel/api/3.la-vista/","tags":"","title":"3.La Vista unitarios"},{"body":"Idea de un componenten el Laravel Un Componente html va a ser un fichero en el que vamos a especificar los tres aspectos fundamentales en un desarrollo html del cliente:\nComportamiento (Código js) Datos o información (código html) Estilo (Css) La estructura del fichero va a tener esta forma 1 2 3 4 5 6 7 8 9 10 11 \u003ctemplate\u003e \u003c!-- Código HTML --\u003e \u003c/template\u003e \u003cscript\u003e // Código Javascript \u003c/script\u003e \u003cstyle\u003e /* Código CSS */ \u003c/style\u003e *Una vez creado el fichero, lo podremos invocar en nuestra página html. Por ejemplo si el fichero anterior lo llamáramos ‘‘‘‘‘cronmetro.vue’’’’’, 1 \u003ccronometro\u003e\u003c/cronometro\u003e Los ficheros han de tener extensión vue, y normalmente los ubicaremos en una carpeta (p.e. ./componentes)\nCrearemos componentes para especificar diferentes elementos con comportamiento que vamos a poder intergrar en nuestra página html\n","categories":"","description":"","excerpt":"Idea de un componenten el Laravel Un Componente html va a ser un …","ref":"/docs/vue/2_componentes/","tags":"","title":"Componentes"},{"body":"Crear un componente tabla Vamos a crear un componente para renderizar en una tabla el resultado de una consulta de html\nAdemás le dotaremos de una serie de método que se ejecutarán en el cliente como es ordenar por un campo concreto o bien filtar las filas por valores que insertemos en una caja de texto\nEjemplo de tabla que queremos implementar La ventaja es evidente: tendremos un componente que podremos usar en cualqueir circunstancia que lo necesitemos, y si necesitamos más funcionalidad, simplemente la añadiremos\nCrear el componente. Ahora hemos de crear un componente vue en el que vamos a renderizar las filas y la cabecera del resultado de una consulta en la base de datos.\nCrearemos un componente llamado listado_tabla.vue en resources/js/componets/listado_tabla.vue con el código base de una tabla\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u003ctemplate\u003e \u003ctable\u003e \u003ccaption\u003e \u003c!--Por ejemplo el nombre de la tabla--\u003e \u003c/caption\u003e \u003ctr\u003e \u003cth\u003e \u003c!--Aquí las nombres de los campos --\u003e \u003c/th\u003e \u003c/tr\u003e \u003ctr\u003e \u003c!--Tantas filas en la tabla como filas haya que listar--\u003e \u003cth\u003e \u003c!--De cada fila visualizo cada valor--\u003e \u003c/th\u003e \u003c/tr\u003e \u003c/table\u003e \u003c/template\u003e \u003cscript\u003e export default { name: \"listado_tabla\" } \u003c/script\u003e \u003cstyle scoped\u003e \u003c/style\u003e En las líneas comentadas y seleccionadas es donde tendremos que poner valores según los casos, por lo que evidencia los valores que he de pasar del back a través de variables\nAhora hay que indicar en el fichero resources/js/app.js que vamos a utilizar el componente creado 1 2 3 4 5 6 7 8 9 10 11 import {createApp} from \"vue/dist/vue.esm-bundler\"; import listado_tabla from \"./components/listado_tabla.vue\"; import saludo from \"./components/saludo.vue\"; createApp({ components:{ listado_tabla, saludo } }).mount(\"#app\"); Generarando datos (back) Ahora necesitamos generar los datos. Esto lo hacemos en el controlador, el cual los pasa al retornar la vista\nPor lo tanto necesitamos la siguiente interacción entre el back y el front. Es muy importante afianzar esta idea y ser consciente de donde estoy en cada momento Listado de la tabla Valores que genero en el back y se los paso al front\nSi concretamos y ponemos nombre a las variables para empezar a programar, una opción sería:\nListado de la tabla Dejamos establecidas estas variables para el componente vue Controlador - Vista Es importante ver que la forma en la que trabajamos con datos estructurados en el back y en el front no son la misma, por lo que hay que buscar un punto de unión, y esto es justo lo que hacemos pasar la informacion serializada para podre reconstruir fácilmente un json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class AlumnoController extends Controller { /** * Display a listing of the resource. */ public function index() { $alumnos = Alumno::all(); //Una manera de obener los nombres de la columna $campos = array_keys($alumnos[0]-\u003egetAttributes()); $tabla =\"Alumnos\"; return view(\"alumnos.listado\", ['filas'=\u003e $alumnos, 'campos'=\u003e$campos, 'tabla'=\u003e$tabla]); } Proceso de serializacion La vista En la vista recibimos los datos del controlador y los cargamos para entregarlos al cliente La imagen anterior deja establecido dicha idea 1 2 3 4 5 6 7 8 @extends (\"layout\"); @section(\"contenido\") @extends (\"layout\"); @section(\"contenido\") \u003clistado_tabla filas_serializadas=@json($filas) campos_serializados=@json($campos) tabla={{$tabla}}\u003e @endsection @endsection Directivas de Vue Ahora tenemos que recoger los valores\n","categories":"","description":"","excerpt":"Crear un componente tabla Vamos a crear un componente para renderizar …","ref":"/docs/vue/3_tabla/","tags":"","title":"Componete Tabla"},{"body":"Directivas Son palabras reservadas que nos van a permitir en la parte del html (vista) usar conceptos de la parte del controlador.\nLa reacción es en dos direcciones, es decir cualquier cambio que hagamos en la parte del html a una variable se reflejará inmediatamente en el controlador y viceversa.\nPor ello se dice de Vue se dice que es un framework reactivo en dos direcciones modelo vista - vista modelo Las directivas en Vue empiezan por la letra v-\ndirectivas Vue Vamos a utilizarlas en nuestro componentes y las vamos a explicar:\nv-text o {{}} Con esta directiva visalizamos el valor de una variable En nuestro caso queremos mostar el valor de la variable tabla 1 2 3 4 5 6 7 8 \u003ctemplate\u003e \u003ctable\u003e \u003ccaption\u003e \u003cdiv v-text=tabla\u003e\u003c/div\u003e \u003c/caption\u003e \u003ctr\u003e \u003cth\u003e \u003c!-- ... resto --\u003e O bien 1 2 3 4 5 6 7 8 \u003ctemplate\u003e \u003ctable\u003e \u003ccaption\u003e {{tabla}} \u003c/caption\u003e \u003ctr\u003e \u003cth\u003e \u003c!-- ... resto --\u003e Usaremos el formato de sintaxis de plantillas o mustache que son las dobles brakets {{}}. No confundir con los dobles brakets de laravel.\nv-for Para iterar sobre una lista o array de valores. En este caso tenemos dos arrays, uno indexado de nombres de campos campos y otro llamado filas que es un array de objetos, donde cada objeto es una tupla o fila de la tabla en la base de datos que estemos visualizando\nPara renderizar los campos 1 2 3 4 5 6 7 8 9 10 \u003ctemplate\u003e \u003ctable\u003e \u003ccaption\u003e {{tabla}} \u003c/caption\u003e \u003ctr\u003e \u003cth v-for=\"campo in campos\"\u003e {{ campo }} \u003c/th\u003e \u003c/tr\u003e En el caso de las filas, hay que realizar una doble iteración. Por un lado recorremos cada fila y creamos un tr, por otro lado recorremos cada campo para visualizar en un td 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u003ctemplate\u003e \u003ctable\u003e \u003ccaption\u003e \u003cdiv v-text=tabla\u003e\u003c/div\u003e {{tabla}} \u003c/caption\u003e \u003ctr\u003e \u003cth v-for=\"campo in campos\"\u003e\u003e {{ campo }} \u003c/th\u003e \u003c/tr\u003e \u003ctr v-for=\"fila in filas\"\u003e \u003ctd v-for=\"valor in fila\"\u003e {{valor}} \u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003c/template\u003e ","categories":"","description":"","excerpt":"Directivas Son palabras reservadas que nos van a permitir en la parte …","ref":"/docs/vue/4_directivas/","tags":"","title":"Directivas de Vue"},{"body":"Métodos Para crear métodos vamos a agregar en el componente el método, que será, en este caso asociaodo a un evento de un elemento html Realizaremos dos métodos: ordenar y filtrar.\nOrdenar Primero, mediante la directiva v-on o con el modo abreviado @ asociamos el evento a un método. Para ello envolvemos el nombre del campo en un botón LA idea es que ordene por el campo que seleccionemos, por lo que deberemos de pasar al método el nombre del campo por el que queremos ordenar 1 2 3 4 5 6 7 8 9 10 11 12 13 \u003ctemplate\u003e \u003ctable\u003e \u003ccaption\u003e {{ tabla }} \u003c/caption\u003e \u003ctr\u003e \u003cth v-for=\"campo in campos\"\u003e \u003cbutton @click=\"ordena(campo)\"\u003e {{ campo }} \u003c/button\u003e \u003c/th\u003e \u003c/tr\u003e \u003c!-- Resto html ...--\u003e Ahora vamos a implmentar la parte de javascript\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 export default { name: \"listado_tabla\", props:['filas_serializadas', 'campos_serializados', 'tabla'] , data() { return { filas: [], campos: [], } }, created() { try { this.filas = JSON.parse(this.filas_serializadas); this.campos = JSON.parse(this.campos_serializados); } catch (e) { this.filas = []; this.campos = []; } }, methods: { ordena(campo) { this.filas = this.filas.sort((a, b) =\u003e { if (a[campo] \u003e b[campo]) retorno = 1; else retorno = -1; return retorno; }); }, } \u003c/script\u003e Mejora: Realiza que la ordenacioń sea en orden ascendente y/o descendente\nfiltrar Para implementar esta funcionalidad deberemos de añadir una caja de texto en cada cabecera, donde podamos escribir un texto para filtrar Además necesitamos que elemento del array de una fila es, para poder ordenar por ese elemento, por lo que observa como en la interacción tomamos también la posición. Añadimos un elemento llamado size para establecer un ancho en cada caja de texto 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u003ctable\u003e \u003ccaption\u003e {{ tabla }} \u003c/caption\u003e \u003ctr\u003e \u003cth v-for=\"(campo,index) in campos\"\u003e\u003e \u003cinput @keyup=\"filtra(campo, valor[index])\" type=\"text\" :size=len_campo[index] v-model='valor[index]'/\u003e \u003cbotton @click=\"ordena(campo)\"\u003e {{ campo }} \u003c/botton\u003e \u003c/th\u003e \u003c/tr\u003e El método se implementaría usando la función filter de javascript 1 2 3 4 5 6 7 8 9 methods: { filtra(campo, valor) { this.filas = this.filas.filter((fila) =\u003e { var texto = new String(fila[campo]); if (texto.indexOf(valor) \u003e -1) return fila } ); }, editar Ahora querremos implmentar el método de editar. Lo único que hay que tener en cuenta, es que no estamos en laravel y no podemos usar los helper de laravel Para realizar una llamada a una url desde javascript, usamos la propiedad window.location.href como se indica en la función 1 2 3 4 editar(id) { var url = window.location.href; window.location.href = url + '/' + id + \"/edit\"; }, borrar Al igual que en el caso anterior, vamos a realizar una llamada desde javascript. En este caso, vamos a realizar una llamada ajax, ya que solo queremos que se actualice el listado eliminando una fila. Vamos a utilziar la librería axios 1 2 3 4 5 6 7 borrar(id) { var url = window.location.href; var self = this; axios.delete(url + \"/\" + id) .then(function (response) { self.filas = response.data; }); Ahora tendríamos que modificar el servidor el método delete del controlador, para que no me retorne un recurso, una página web, sino solo datos que es lo que el cliente espera recibir, por lo que el objeto response que retorna laravel, en este caso será un array de empleados en formato json. 1 2 3 4 5 6 public function destroy(Empleado $empleado) { $empleado-\u003edelete(); $empleados=Empleado::all(); return response($empleados); } ","categories":"","description":"","excerpt":"Métodos Para crear métodos vamos a agregar en el componente el método, …","ref":"/docs/vue/5_metodos/5_metodos/","tags":"","title":"Métodos"},{"body":"Instalar Paginación en tailwind Para usar la paginación, ahora tendremos que hacer unas adaptaciones para que pueda funcionar, ya que la interacción entre cliente y servidor se realiza desde javascript.\nLa paginación la controla el servidor, ya que nos va proporcionando trozos de la consulta según vayamos requiriendo\nLo primero que vamos a hacer es instalar un componente de tailwind para el estilo de los botones de navegación\n1 2 3 4 5 6 7 8 9 10 const defaultTheme = require('tailwindcss/defaultTheme'); /** @type {import('tailwindcss').Config} */ module.exports = { content: [ './vendor/laravel/framework/src/Illuminate/Pagination/resources/views/*.blade.php', './storage/framework/views/*.php', './resources/views/**/*.blade.php', './vendor/laravel/framework/src/Illuminate/Pagination/resources/views/*.blade.php', ], Debemos instalar el componente de paginación de tailwind para vue 1 npm install laravel-vue-pagination Posteriormente, hay que cargarla en el componente de listado_tabla.vue 1 2 3 4 5 6 7 8 9 10 \u003cscript\u003e import axios from 'axios'; import {TailwindPagination} from 'Laravel-Vue-pagination'; export default { name: \"tabla\", components: { TailwindPagination, }, // resto de componente Y agregamos el componente al final de la tabla. Establemcemos el método getResults para gestionar los eventos de los botones que aparecen 1 2 3 4 5 6 7 8 9 10 11 \u003c!--elementos table--\u003e \u003c/table\u003e \u003chr\u003e \u003cspan class=\"text-blue-700 text-4xl\"\u003e \u003cTailwindPagination :data=\"filas\" @pagination-change-page=\"getResults\" /\u003e \u003c/span\u003e \u003chr\u003e \u003chr\u003e Y ahora hay que interactuar con el servidor. Empecemos por el index del controlador. Lo único que cambia es que ahora entregamos 10 filas en lugar de todas\n1 2 3 4 5 6 7 8 9 10 11 12 public function index() { $alumnos = Alumno::paginate(10); //Una manera de obener los nombres de la columna $campos = array_keys($alumnos[0]-\u003egetAttributes()); $tabla =\"Alumnos\"; return view(\"alumnos.listado\", ['filas'=\u003e $alumnos, 'campos'=\u003e$campos, 'tabla'=\u003e$tabla]); } A la hora de recorrer las filas, ahora el método paginate no retorna una colección de modelos, sino un objeto paginator (LengthAwarePaginator), que al serializarlo, el comonente Vue recibe en el elemnto data los datos, por lo que hay que recorrer el elemento data de filas 1 2 3 4 5 \u003ctr v-for=\"fila in filas.data\"\u003e \u003ctd v-for=\"valor in fila\"\u003e {{ valor }} \u003c/td\u003e \u003c/tr\u003e Y ahora implmentamos el método del cliente 1 2 3 4 5 6 7 8 9 10 11 12 13 getResults(page = 1) { let url = window.location.href; let self = this; axios.get( url + \"/paginate?page=\" + page) .then(function (response) { self.filas = response.data; console.log(\"Respuesta \" + response.data); }) .catch(function (error) { console.error(\"ERROR\"+error); }); } Nos quedaría terminar el proceso, es decir, agregar la ruta /paginate en el fichero de rutas web.php e implementar el método correspondiente\nCuidado al añadir la ruta, si la ponemos después de resources, no funcionará.\nEsto sucede porque la ruta asignada para los métodos del resource que tienen parámetros, concretamente la ruta EmpresaController@show\nGET|HEAD empresas/paginate ……….. EmpresaController@get_paginate GET|HEAD empresas/{empresa} .. empresas.show › EmpresaController@show\nno tiene restricciones, es decir, puede ser un número o una cadena de texto Para solucionarlo tenemos dos opciones: 1.- Establecer la ruta de paginate antes que la de resources 2.- Establecer un patrón para {empresa}, especificando que tiene que ser un número\n1 Route::get(\"alumnos/paginate\",[ \\App\\Http\\Controllers\\AlumnoController::class,\"get_paginate\"] ); Y en el fichero del 2.VisionGeneral agretamos el método get_paginate 1 2 3 4 public function get_paginate(){ $empleados=Empleado::paginate(10); return response($empleados); } ","categories":"","description":"","excerpt":"Instalar Paginación en tailwind Para usar la paginación, ahora …","ref":"/docs/vue/7_paginacion/","tags":"","title":"Paginación con Vue y taildwind"},{"body":"El desarrollo Web en el entorno servidor Qué pretende explicar este módulo Desarrollar una aplicación Una Aplicación Web Aplicaciones Web Especificando el recurso Cómo son los programas que permiten que una red funcione Qué es la ip Qué es el puerto Algunos comandos importantes Los medios físicos y lógicos del proceso web El servidor en el proceso de ejecución de una aplicación web Servidor web El comando curl ","categories":"","description":"","excerpt":"El desarrollo Web en el entorno servidor Qué pretende explicar este …","ref":"/docs/01_web/01_conceptos_generales/","tags":"","title":"Conceptos Generales"},{"body":" Desarrollo Web Contenido Ejercicios Prácticas Acceso al wiki Vídeos Referencias Disfruta mientras aprendes!! Ciclo superior de desarrollo de aplicaciones web\nProgramación web en entorno servidor Recursos PHP Laravel Github ","categories":"","description":"","excerpt":" Desarrollo Web Contenido Ejercicios Prácticas Acceso al wiki Vídeos …","ref":"/","tags":"","title":"Desarrollo Web"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"}]